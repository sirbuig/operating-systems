"use strict";(self.webpackChunkoperating_systems=self.webpackChunkoperating_systems||[]).push([[4550],{4606:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var s=n(4848),i=n(8453);const r={sidebar_position:2},o="The Critical-Section Problem",c={id:"week-6/critical-section",title:"The Critical-Section Problem",description:"To guard against the race condition previously discussed, we need to ensure that only one process at a time can be manipulating the variable count. To make such a guarantee, we require that the processes be synchronized in some way.",source:"@site/docs/week-6/critical-section.md",sourceDirName:"week-6",slug:"/week-6/critical-section",permalink:"/operating-systems/week-6/critical-section",draft:!1,unlisted:!1,editUrl:"https://github.com/sirbuig/operating-systems/tree/main/docs/week-6/critical-section.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Process Synchronization Background",permalink:"/operating-systems/week-6/background"},next:{title:"Mutex Locks",permalink:"/operating-systems/week-6/mutex-locks"}},a={},l=[{value:"Requirements",id:"requirements",level:2},{value:"Peterson&#39;s solution",id:"petersons-solution",level:2},{value:"Hardware Instructions",id:"hardware-instructions",level:2},{value:"<code>test_and_set()</code>",id:"test_and_set",level:3},{value:"<code>compare_and_swap()</code>",id:"compare_and_swap",level:3}];function d(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"the-critical-section-problem",children:"The Critical-Section Problem"})}),"\n",(0,s.jsxs)(t.p,{children:["To guard against the race condition previously discussed, we need to ensure that ",(0,s.jsx)(t.strong,{children:"only one process"})," at a time can be manipulating the variable ",(0,s.jsx)(t.code,{children:"count"}),". To make such a guarantee, we require that the processes be ",(0,s.jsx)(t.strong,{children:"synchronized"})," in some way."]}),"\n",(0,s.jsxs)(t.p,{children:["Consider a system consisting of ",(0,s.jsx)(t.code,{children:"n"})," processes ",(0,s.jsx)(t.code,{children:"{P0, P1, ..., Pn-1}"}),", each having a segment of code called ",(0,s.jsx)(t.strong,{children:"critical section"}),", in which the process may be accessing and updating data that is shared with at least one other process."]}),"\n",(0,s.jsxs)(t.admonition,{type:"note",children:[(0,s.jsxs)(t.p,{children:["The important feature is that ",(0,s.jsx)(t.strong,{children:"no"})," two processes are executing in their critical sections ",(0,s.jsx)(t.strong,{children:"at the same time"}),"."]}),(0,s.jsx)(t.p,{children:"Each process must request permission to enter its critical section."})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"critical-section",src:n(1360).A+"",width:"679",height:"370"})}),"\n",(0,s.jsx)(t.h2,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsx)(t.p,{children:"A solution to the critical-section problem must satisfy the following three requirements:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Mutual exclusion"}),": If process ",(0,s.jsx)(t.code,{children:"Pi"})," is executing in its critical section, then no other processes can be executing in their critical sections."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Progress"}),": If no process is executing in its critical section, but there are processes that actively wish to enter their critical sections, then there is a guarantee that eventually some process will be selected (i.e. no process can be blocked forever)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Bounded waiting"}),": There exists a bound, or limit, on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"petersons-solution",children:"Peterson's solution"}),"\n",(0,s.jsx)(t.p,{children:"This is a classic software-based solution to the critical-section problem. Because of the way modern computer architectures perform basic machine-language isntructions, there are no guarantees that Peterson's solution will work correctly on such architectures."}),"\n",(0,s.jsx)(t.p,{children:"However, it's important to be studied because it provides a good algorithmic description that addresses the requirements."}),"\n",(0,s.jsxs)(t.p,{children:["Peterson's solution is restricted to two processes, ",(0,s.jsx)(t.code,{children:"P0"})," and ",(0,s.jsx)(t.code,{children:"P1"}),", or for convenience, ",(0,s.jsx)(t.code,{children:"Pi"})," and ",(0,s.jsx)(t.code,{children:"Pj"})," with ",(0,s.jsx)(t.code,{children:"j = 1 - i"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"The two processes share two data items:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"// whose turn it is to enter its critical section\n// turn == i => Pi is allowed to execute in its critical section\nint turn;\n\n// indicates if a process is ready to enter\n// flag[i] = true => Pi is ready to enter its critical section\nboolean flag[2];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Let's describe the algorithm:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",metastring:'title="petersons_solution.c"',children:"// Pi POV\nwhile(true) {\n    // I (Pi) am ready to enter my critical section\n    flag[i] = true;\n\n    // if Pj wishes to enter the cs, it can do so\n    turn = j;\n\n    // if both want to enter at the same time\n    // turn will be set to both i and j at the same time\n    // only one will last, the other will be overwritten\n    // the eventual value determines which is allowed to enter first\n\n    // if Pj wished to enter and is really his turn,\n    // then I have nothing to do\n    while (flag[j] && turn == j)\n        ;\n\n    /* critical section */\n\n    // I don't want to enter my cs anymore\n    flag[i] = false;\n\n    /* remainder section */\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"hardware-instructions",children:"Hardware Instructions"}),"\n",(0,s.jsxs)(t.p,{children:["Many modern computer systems provide special hardware instructions that allow us either to test and modify the content of a word or to swap the contents of two words ",(0,s.jsx)(t.strong,{children:"atomically"})," - that is, as one uninterruptible unit."]}),"\n",(0,s.jsx)(t.p,{children:"These special instructions will help us solve the critical-section problem in a relatively simple mnner."}),"\n",(0,s.jsx)(t.h3,{id:"test_and_set",children:(0,s.jsx)(t.code,{children:"test_and_set()"})}),"\n",(0,s.jsxs)(t.p,{children:["The important characteristic of ",(0,s.jsx)(t.code,{children:"test_and_set()"})," is that it is executed atomically."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"boolean test_and_set(boolean *target) {\n    boolean rv = *target;\n    *target = true;\n\n    return rv;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We can implement ",(0,s.jsx)(t.strong,{children:"mutual exclusion"})," by declaring a boolean variable ",(0,s.jsx)(t.code,{children:"lock = false"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",metastring:'title="mutex.c"',children:"// Pi POV\ndo {\n    // if the lock is true, then someone else is in their cs\n    // if it's false, then I can enter my cs and I set it true\n    while (test_and_set(&lock))\n        ;\n\n    /* critical section */\n\n    lock = false;\n\n    /* remainder section */\n} while (true);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"compare_and_swap",children:(0,s.jsx)(t.code,{children:"compare_and_swap()"})}),"\n",(0,s.jsx)(t.p,{children:"The CAS instruction operates on two words atomically, but uses a different mechanism that is based on swapping the content of two words."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"int compare_and_swap(int *value, int expected, int new_value) {\n    int temp = *value;\n\n    if (*value == expected)\n        *value = new_value;\n\n    return temp;\n}\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",metastring:'title="mutex.c"',children:"while (true) {\n    // Pi POV\n\n    // if the lock is false as I expect, set it true\n    // if it's true, then someone else is in their cs\n    while (compare_and_swap(&lock, 0, 1) != 0)\n        ;\n\n    /* critical section */\n\n    // another process can enter its cs\n    lock = 0;\n\n    /* remainder section */\n}\n"})}),"\n",(0,s.jsxs)(t.admonition,{type:"danger",children:[(0,s.jsx)(t.p,{children:"This algorithm does not satisfy the bounded-waiting requirement!"}),(0,s.jsx)(t.p,{children:"Check the book for a solution that solves the issue."})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1360:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/critical-section-b68c4fcbbdbe76c8c70369d80f93f4a0.png"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);