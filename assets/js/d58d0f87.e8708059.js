"use strict";(self.webpackChunkoperating_systems=self.webpackChunkoperating_systems||[]).push([[3387],{9872:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>a,toc:()=>c});var o=s(4848),r=s(8453);const n={sidebar_position:2},i="Contiguous Memory Allocation",a={id:"week-10/main-memory/memory-allocation",title:"Contiguous Memory Allocation",description:"Main memory must hold both the operating system and user processes, so it needs to be allocated efficiently. One early method for this is contiguous memory allocation.",source:"@site/docs/week-10/main-memory/memory-allocation.md",sourceDirName:"week-10/main-memory",slug:"/week-10/main-memory/memory-allocation",permalink:"/operating-systems/week-10/main-memory/memory-allocation",draft:!1,unlisted:!1,editUrl:"https://github.com/sirbuig/operating-systems/tree/main/docs/week-10/main-memory/memory-allocation.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Background",permalink:"/operating-systems/week-10/main-memory/background"},next:{title:"Simulation of pagination in C",permalink:"/operating-systems/week-10/page_problem"}},l={},c=[{value:"Memory Protection",id:"memory-protection",level:2},{value:"Memory Allocation",id:"memory-allocation",level:2},{value:"Fragmentation",id:"fragmentation",level:2}];function m(e){const t={admonition:"admonition",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"contiguous-memory-allocation",children:"Contiguous Memory Allocation"})}),"\n",(0,o.jsxs)(t.p,{children:["Main memory must hold both the ",(0,o.jsx)(t.strong,{children:"operating system"})," and ",(0,o.jsx)(t.strong,{children:"user processes"}),", so it needs to be allocated efficiently. One early method for this is ",(0,o.jsx)(t.strong,{children:"contiguous memory allocation"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Memory is divided into two partitions: one for the operating system and one for user processes. The operating system can be placed in either ",(0,o.jsx)(t.strong,{children:"low memory"})," or ",(0,o.jsx)(t.strong,{children:"high memory"}),", depending on factors like the interrupt vector's location. Many operating systems, such as Linux and Windows, place the operating system in high memory, so we\u2019ll focus on that setup."]}),"\n",(0,o.jsxs)(t.p,{children:["To run multiple user processes simultaneously, we need to allocate memory for each process. In ",(0,o.jsx)(t.strong,{children:"contiguous memory allocation"}),", each process is assigned a single, continuous block of memory, located next to the memory block of the next process. Before diving deeper into this allocation method, we first need to discuss ",(0,o.jsx)(t.strong,{children:"memory protection"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"memory-protection",children:"Memory Protection"}),"\n",(0,o.jsxs)(t.p,{children:["We can prevent a process from accessing unauthorized memory by using a ",(0,o.jsx)(t.strong,{children:"relocation register"})," and a ",(0,o.jsx)(t.strong,{children:"limit register"})," together. The relocation register holds the smallest physical address for the process, and the limit register defines the range of allowable logical addresses (e.g., relocation = 100040, limit = 74600). Every logical address generated by the process must fall within this range. The ",(0,o.jsx)(t.strong,{children:"MMU"})," dynamically adds the relocation value to the logical address to create the physical address, which is then sent to memory."]}),"\n",(0,o.jsxs)(t.p,{children:["During a ",(0,o.jsx)(t.strong,{children:"context switch"}),", the dispatcher updates the relocation and limit registers for the selected process. Since all CPU-generated addresses are checked against these registers, this setup ensures the running process cannot access or modify the operating system or other users' memory."]}),"\n",(0,o.jsx)(t.p,{children:"The relocation-register scheme also allows the operating system to adjust its size dynamically. For instance, code and buffers for device drivers can be loaded into memory only when needed and removed afterward, freeing memory for other uses. This flexibility is particularly useful for optimizing memory usage."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Hardware Support",src:s(8586).A+"",width:"592",height:"342"})}),"\n",(0,o.jsx)(t.h2,{id:"memory-allocation",children:"Memory Allocation"}),"\n",(0,o.jsxs)(t.p,{children:["Memory allocation can be done using a ",(0,o.jsx)(t.strong,{children:"variable-partition scheme"}),", where processes are assigned to partitions of different sizes. Each partition holds exactly one process. The operating system maintains a table tracking which parts of memory are free and which are in use. Initially, all memory is available as one large block, called a ",(0,o.jsx)(t.strong,{children:"hole"}),". Over time, as processes enter and leave, memory becomes a mix of occupied sections and holes of various sizes."]}),"\n",(0,o.jsx)(t.p,{children:"For example, memory might start fully occupied with processes 5, 8, and 2. When process 8 leaves, a single hole appears. Later, process 9 is allocated memory. When process 5 exits, two noncontiguous holes are left."}),"\n",(0,o.jsx)(t.p,{children:"When a process arrives, the operating system checks its memory needs against available holes. If a hole is large enough, it is split into two parts: one for the process and one for the remaining space, which goes back to the set of holes. When a process terminates, its memory is freed and returned to the holes. If adjacent holes are created, they are merged into a larger hole."}),"\n",(0,o.jsx)(t.p,{children:"If there\u2019s not enough memory for a process, the operating system can either reject it with an error message or place it in a wait queue. When memory becomes available, the system checks if the waiting process can now be accommodated."}),"\n",(0,o.jsx)(t.p,{children:"This system is part of the broader dynamic storage-allocation problem, which focuses on finding space for processes efficiently. Common strategies include:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"First-fit"}),": Use the first hole that is big enough."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Best-fit"}),": Use the smallest hole that fits the process."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Worst-fit"}),": Use the largest available hole."]}),"\n"]}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsx)(t.p,{children:"Simulations have shown that both first fit and best fit are better than worst\nfit in terms of decreasing time and storage utilization. Neither first fit nor best\nfit is clearly better than the other in terms of storage utilization, but first fit is\ngenerally faster."})}),"\n",(0,o.jsx)(t.h2,{id:"fragmentation",children:"Fragmentation"})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},8586:(e,t,s)=>{s.d(t,{A:()=>o});const o=s.p+"assets/images/hardware_support-4794f7d18494ea668e47f6d5bc92d4a1.png"},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>a});var o=s(6540);const r={},n=o.createContext(r);function i(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);