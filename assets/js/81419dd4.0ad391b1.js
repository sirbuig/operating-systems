"use strict";(self.webpackChunkoperating_systems=self.webpackChunkoperating_systems||[]).push([[8668],{9879:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var s=n(4848),t=n(8453);const r={sidebar_position:1,title:"Synchronization Recap",description:"Course revision"},o=void 0,a={id:"revision/synchronization_recap",title:"Synchronization Recap",description:"Course revision",source:"@site/docs/revision/synchronization_recap.md",sourceDirName:"revision",slug:"/revision/synchronization_recap",permalink:"/operating-systems/revision/synchronization_recap",draft:!1,unlisted:!1,editUrl:"https://github.com/sirbuig/operating-systems/tree/main/docs/revision/synchronization_recap.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Synchronization Recap",description:"Course revision"},sidebar:"tutorialSidebar",previous:{title:"Revision",permalink:"/operating-systems/category/revision"}},c={},l=[{value:"Requirements",id:"requirements",level:2},{value:"Solutions",id:"solutions",level:2},{value:"Peterson&#39;s Solution",id:"petersons-solution",level:3},{value:"Hardware Instructions",id:"hardware-instructions",level:3},{value:"Liveness",id:"liveness",level:2},{value:"Deadlock",id:"deadlock",level:3},{value:"Priority Inversion",id:"priority-inversion",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"References",id:"references",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(i.p,{children:["Take a quick glance ",(0,s.jsx)(i.a,{href:"https://sirbuig.github.io/operating-systems/category/week-6",children:"here"})," to refresh your concepts."]}),"\n",(0,s.jsxs)(i.p,{children:["Some key concepts from the ",(0,s.jsx)(i.a,{href:"https://techiefood4u.wordpress.com/wp-content/uploads/2020/02/operating_systems_three_easy_pieces.pdf",children:"Comet Book (yeah the one that killed the Dinosaurs, ha)"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["A ",(0,s.jsx)(i.strong,{children:"critical section"})," is a piece of code that accesses a ",(0,s.jsx)(i.em,{children:"shared"})," resource, usually a variable or data structure."]}),"\n",(0,s.jsxs)(i.li,{children:["A ",(0,s.jsx)(i.strong,{children:"race condition"})," arises if multiple threads of execution enter the critical section at roughly the same time; both attempt to update the shared data structure, leading to a surprising (and perhaps undesirable) outcome."]}),"\n",(0,s.jsxs)(i.li,{children:["An ",(0,s.jsx)(i.strong,{children:"indeterminate"})," program consists of one or more race conditions; the output of the program varies from run to run, depending on which threads ran when. The outcome is thus not deterministic, something we usually expect from computer systems."]}),"\n",(0,s.jsxs)(i.li,{children:["To avoid these problems, threads should use some kind of ",(0,s.jsx)(i.strong,{children:"mutual exclusion"})," primitives; doing so guarantees that only a single thread ever enters a critical section, thus avoiding races, and resulting in deterministic program outputs."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsxs)(i.admonition,{type:"tip",children:[(0,s.jsxs)(i.p,{children:["Remember that a solution to the ",(0,s.jsx)(i.strong,{children:"critical-section problem"})," must CHECK all these requirements:"]}),(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Mutual exclusion"}),". This property guarantees that if one thread is executing within the critical section, the others will be prevented from doing so."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Progress"}),". If no process is in its critical section and some want to enter, the decision is made only by processes that are actively competing for entry, not those doing other tasks. This ensures that selection happens without indefinite delay."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Bounded waiting"}),". A process that requests entry to its critical section will get in after a limited number of other processes have entered."]}),"\n"]})]}),"\n",(0,s.jsx)(i.h2,{id:"solutions",children:"Solutions"}),"\n",(0,s.jsx)(i.h3,{id:"petersons-solution",children:"Peterson's Solution"}),"\n",(0,s.jsxs)(i.p,{children:["Is discussed ",(0,s.jsx)(i.a,{href:"https://sirbuig.github.io/operating-systems/week-6/critical-section#petersons-solution",children:"here"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"hardware-instructions",children:"Hardware Instructions"}),"\n",(0,s.jsx)(i.p,{children:"To ensure safe access to shared resources, we use atomic operations, meaning they execute without interruption. This improves performance and prevents race conditions."}),"\n",(0,s.jsx)(i.p,{children:"However, implementing atomic execution for all instructions would require special hardware. Instead, we generalize the concept using specific atomic operations, such as:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"test_and_set()"}),";"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"compare_and_swap()"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This allows synchronization without requiring entirely new machine architectures."}),"\n",(0,s.jsxs)(i.p,{children:["Commented code to each of them can be found ",(0,s.jsx)(i.a,{href:"https://sirbuig.github.io/operating-systems/week-6/critical-section#hardware-instructions",children:"here"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"test_and_set()"})," is commonly used for implementing ",(0,s.jsx)(i.strong,{children:"simple locks"}),". It atomically ",(0,s.jsx)(i.strong,{children:"tests if a lock is already set"})," and then sets it, ensuring only one thread can acquire the lock at a time."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"compare_and_swap()"})," is used in ",(0,s.jsx)(i.strong,{children:"lock-free data structures"})," because it ",(0,s.jsx)(i.strong,{children:"compares a memory location with an expected value and swaps it if they match"}),". This allows for atomic updates of pointers in structures like lock-free stacks, queues, and linked lists."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"Lock-Free Example"}),": ",(0,s.jsx)(i.code,{children:"compare_and_swap()"})," enables concurrent push and pop without a mutex, as seen in lock-free stacks. Since it avoids traditional locks, it is less susceptible to deadlocks and helps in high-performance, multi-threaded applications."]}),"\n",(0,s.jsxs)(i.p,{children:["In the Dino Book (Figure 6.9, page 268) we are told ",(0,s.jsx)(i.code,{children:"compare_and_swap()"})," does not meet the ",(0,s.jsx)(i.strong,{children:"bounded-waiting"})," requirement. However, we receive a solution for that:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-c",metastring:'title="bounded-waiting mutual-exclusion"',children:"// elements in waiting are initialized to false\n// lock is 0\n\n// a process Pi can enter when waiting[i] == false\n// OR\n// key == 0\n\n// Pi POV\nwhile(true) { // while I want to enter the CS\n\n    /* ENTRY SECTION */\n\n    // 1. Declare interest in entering the CS\n    waiting[i] = true; // Pi is now waiting\n\n    // 2. Let's acquire the lock\n\n    // the 'key' variable determines if the lock was\n    // successfully acquired\n    key = 1; // 1 means the lock is closed\n\n    // loop loop loop until\n    //  a) waiting[i] = false (we've been granted access from some other process)\n    //  b) key becomes 0 aka lock is free\n    while (waiting[i] && key == 1)\n        // We attempt to set the lock from 0 to 1 atomically\n        // lock is 0 (free) => key becomes 0 so the loop exits\n        // lock is 1 (occupied) => key remains 1 so the loop continues\n        key = compare_and_swap(&lock, 0, 1);\n\n    // I no longer want to wait, I proceed into the CS\n    waiting[i] = false;\n\n    /* CRITICAL SECTION */\n\n\n    /* EXIT SECTION */\n    // I must allow another waiting process (if it exists) to guarantee fairness. So we're scanning the array in a cyclic order.\n\n    // The next process following Pi\n    j = (i+1) % n;\n\n    // Keep scanning until we find a waiting process, otherwise loop back to Pi\n    while ((j != i) && !waiting[j])\n        j = (j+1) % n; // just the next process\n\n    if (j == i)\n        // We found no other process waiting\n        // So we'll release lock\n        lock = 0;\n    else\n        // We found a process waiting\n        // We \"hand over\" the permission, by deactivating waiting and allowing Pj to exit its busy-wait loop and enter the CS\n        waiting[j] = false;\n\n    /* REMAINDER SECTION */\n}\n"})}),"\n",(0,s.jsx)(i.h2,{id:"liveness",children:"Liveness"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Liveness"}),' refers to a set of properties that a system must satisfy to ensure that processes make progress during their execution life cycle. A process waiting indefinitely under the circumstances just described is an example of a \u201cliveness failure".']}),"\n",(0,s.jsxs)(i.p,{children:["A very simple example of a liveness failure is an infinite loop. A ",(0,s.jsx)(i.strong,{children:"busy wait loop"})," presents the possibility of a liveness failure, especially if a process may loop an arbitrarily long period of time."]}),"\n",(0,s.jsx)(i.h3,{id:"deadlock",children:"Deadlock"}),"\n",(0,s.jsxs)(i.p,{children:["Deadlock is covered ",(0,s.jsx)(i.a,{href:"https://sirbuig.github.io/operating-systems/week-8/synchronization-examples/deadlock",children:"here"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"priority-inversion",children:"Priority Inversion"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"DinoBookFragment",src:n(3273).A+"",width:"725",height:"644"})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"PriorityInversion_PickNik",src:n(9291).A+"",width:"1027",height:"850"})}),"\n",(0,s.jsx)(i.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.cs.cornell.edu/courses/cs614/1999sp/papers/pathfinder.html",children:"What really happened on Mars Rover Pathfinder"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://picknik.ai/real-time/priority%20inversion/roscon/2024/01/31/Real-Time_Programming_Priority_Inversion.html",children:"Real-Time Programming: Priority Inversion"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://www.youtube.com/watch?v=ufdQ0GR855M",children:"Monitors - Neso Academy"})}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Operating Systems Concepts, 10th edition, Chapter 6 - Synchronization Tools"}),"\n",(0,s.jsx)(i.li,{children:"Operating Systems - Three Easy Pieces, Part II - Concurrency"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},3273:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/priority_inversion_book-1608052620fd1eacb34eb116154ee88b.png"},9291:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/priority_inversion_picknik-82b2da9c9e8c65b05db73e5b14e9f31a.png"},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var s=n(6540);const t={},r=s.createContext(t);function o(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);