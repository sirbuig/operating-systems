"use strict";(self.webpackChunkoperating_systems=self.webpackChunkoperating_systems||[]).push([[872],{1465:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var r=t(4848),s=t(8453);const i={sidebar_position:1},o="Process Synchronization Background",c={id:"week-6/background",title:"Process Synchronization Background",description:"A system typically consists of several (perhaps hundreds or even thousands) of threads running either concurrently or in parallel. As we saw in the last chapter about threads, they share user data.",source:"@site/docs/week-6/background.md",sourceDirName:"week-6",slug:"/week-6/background",permalink:"/operating-systems/week-6/background",draft:!1,unlisted:!1,editUrl:"https://github.com/sirbuig/operating-systems/tree/main/docs/week-6/background.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Week 6",permalink:"/operating-systems/category/week-6"},next:{title:"The Critical-Section Problem",permalink:"/operating-systems/week-6/critical-section"}},a={},d=[{value:"Producer-Consumer problem",id:"producer-consumer-problem",level:2},{value:"Shared memory approach",id:"shared-memory-approach",level:3},{value:"Adding <code>count</code>",id:"adding-count",level:3},{value:"Understanding the paradox",id:"understanding-the-paradox",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"process-synchronization-background",children:"Process Synchronization Background"})}),"\n",(0,r.jsx)(n.p,{children:"A system typically consists of several (perhaps hundreds or even thousands) of threads running either concurrently or in parallel. As we saw in the last chapter about threads, they share user data."}),"\n",(0,r.jsxs)(n.p,{children:["When the shared data is not controlled, corrupt data values may appear, this phenomenon being called a ",(0,r.jsx)(n.strong,{children:"race condition"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"producer-consumer-problem",children:"Producer-Consumer problem"}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:"Do you remember what a cooperating process was?"}),(0,r.jsxs)(n.p,{children:["If not, see ",(0,r.jsx)(n.a,{href:"http://localhost:3000/operating-systems/week-5/ipc",children:"last week's chapter"}),"."]})]}),"\n",(0,r.jsxs)(n.p,{children:["To illustrate the concept of cooperating processes, let's consider the ",(0,r.jsx)(n.strong,{children:"producer-consumer"})," problem, a common paradigm for cooperating processes."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"producer"})," process produces information that is consumed by a ",(0,r.jsx)(n.strong,{children:"consumer"})," process."]}),"\n",(0,r.jsxs)(n.p,{children:["One solution to this problem involves shared memory, a concept introduced in the last chapter, as well. To allow both producer and consumer processes to run concurrently, we must have a viable buffer of items that can be ",(0,r.jsx)(n.strong,{children:"filled by the producer"})," and ",(0,r.jsx)(n.strong,{children:"emptied by the consumer"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The buffer will be the region of memory that will be shared."}),"\n",(0,r.jsxs)(n.p,{children:["We want the producer and consumer to be ",(0,r.jsx)(n.strong,{children:"synchronized"})," so that the consumer does not try to consume an item that has not yet been produced!"]}),"\n",(0,r.jsx)(n.h3,{id:"shared-memory-approach",children:"Shared memory approach"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Let's define our ",(0,r.jsx)(n.strong,{children:"bounded buffer"})," (in this case the consumer must wait if the buffer is empty, and the producer must wait if the buffer is full), our item and the variables ",(0,r.jsx)(n.code,{children:"in"})," and ",(0,r.jsx)(n.code,{children:"out"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"// fixed buffer size\n#define BUFFER_SIZE 10\n\n// we define our item\ntypedef struct {\n    // ...\n} item;\n\n// circular array with 2 logical pointers, in and out\nitem buffer[BUFFER_SIZE];\n\n// in points to the next free position in the buffer\nint in = 0;\n\n// out points to the first full position of the buffer\nint out = 0;\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["The buffer is ",(0,r.jsx)(n.strong,{children:"empty"})," when ",(0,r.jsx)(n.code,{children:"in == out"}),"."]}),(0,r.jsxs)(n.p,{children:["The buffer is ",(0,r.jsx)(n.strong,{children:"full"})," when ",(0,r.jsx)(n.code,{children:"((in + 1) % BUFFER_SIZE) == out"}),"."]})]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"Now let's implement the producer:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'item next_produced;\n\nwhile(true) {\n    /* produce an item in next_produced */\n\n    // if the buffer is full, do nothing\n    while( ((in + 1) % BUFFER_SIZE) == out)\n        ;\n\n    // otherwise, add the produced item in the buffer\n    buffer[in] = next_produced;\n    // calculate the next "pointer" to the free position\n    in = (in + 1) % BUFFER_SIZE;\n}\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"The consumer, as well:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'item next_consumed;\n\nwhile(true) {\n    // if the buffer is empty, do nothing\n    while (in == out)\n        ;\n\n    // select the item to consume\n    next_consumed = buffer[out];\n    // calculate the next "pointer" to the full position\n    out = (out + 1) % BUFFER_SIZE;\n\n    /* consume the item in next_consumed */\n}\n'})}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["The buffer is ",(0,r.jsx)(n.strong,{children:"circular"}),", with ",(0,r.jsx)(n.code,{children:"in"})," and ",(0,r.jsx)(n.code,{children:"out"}),' "chasing" each other. Watch this ',(0,r.jsx)(n.a,{href:"https://youtu.be/VXJSJ6c3ZIs?feature=shared",children:"excellent short video"})," for more."]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Ring Buffer",src:t(3010).A+"",width:"897",height:"392"})})]}),"\n",(0,r.jsxs)(n.admonition,{title:"THINK ABOUT IT!",type:"danger",children:[(0,r.jsx)(n.p,{children:"Do you think this illustration is fully correct?"}),(0,r.jsx)(n.p,{children:"How many items can we have at most in our buffer?"})]}),"\n",(0,r.jsxs)(n.p,{children:["Although the code above is correct, we have a little setback. Only ",(0,r.jsx)(n.code,{children:"BUFFER_SIZE-1"})," elements are allowed in the buffer (take a pen and paper and see it for youself)!"]}),"\n",(0,r.jsxs)(n.h3,{id:"adding-count",children:["Adding ",(0,r.jsx)(n.code,{children:"count"})]}),"\n",(0,r.jsxs)(n.p,{children:["To solve this, we can add a variable ",(0,r.jsx)(n.code,{children:"count = 0;"})]}),"\n",(0,r.jsxs)(n.p,{children:["We'll ",(0,r.jsx)(n.strong,{children:"increment"}),", ",(0,r.jsx)(n.code,{children:"count++"}),", when adding a new item to the buffer and ",(0,r.jsx)(n.strong,{children:"decrement"}),", ",(0,r.jsx)(n.code,{children:"count--"}),", when removing one item from the buffer."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"New Producer"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'item next_produced;\n\nwhile(true) {\n   /* produce an item in next_produced */\n\n   // if the buffer is full, do nothing\n   while( count == BUFFER_SIZE )\n       ;\n\n   // otherwise, add the produced item in the buffer\n   buffer[in] = next_produced;\n   // calculate the next "pointer" to the free position\n   in = (in + 1) % BUFFER_SIZE;\n   count++;\n}\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"New Consumer"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'item next_consumed;\n\nwhile(true) {\n   // if the buffer is empty, do nothing\n   while (count == 0)\n       ;\n\n   // select the item to consume\n   next_consumed = buffer[out];\n   // calculate the next "pointer" to the full position\n   out = (out + 1) % BUFFER_SIZE;\n   count--;\n   /* consume the item in next_consumed */\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Super, now everything makes even more sense and we have ",(0,r.jsx)(n.code,{children:"BUFFER_SIZE"})," items as we wanted! Surely, we solved this problem, right?"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"MEME",src:t(5905).A+"",width:"500",height:"500"})}),"\n",(0,r.jsx)(n.p,{children:"Well, not really, because this raises even bigger issues!"}),"\n",(0,r.jsx)(n.p,{children:"Although the producer and consumer routines shown above are correct separately, they may not function correctly when executed concurrently!"}),"\n",(0,r.jsxs)(n.p,{children:["To observe this claim, let's take the following case: imagine ",(0,r.jsx)(n.code,{children:"count = 5"})," and 2 operations are next, ",(0,r.jsx)(n.code,{children:"count++"})," and then ",(0,r.jsx)(n.code,{children:"count--"}),". Of course, the correct and final answer after the 2 statements are executed should be ",(0,r.jsx)(n.code,{children:"count=5"}),", however that's not the case! In reality, we can have ",(0,r.jsx)(n.strong,{children:"3 outputs"}),", namely ",(0,r.jsx)(n.code,{children:"count=4"}),", ",(0,r.jsx)(n.code,{children:"count=5"})," and ",(0,r.jsx)(n.code,{children:"count=6"}),"! \ud83e\udd2f"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"count issue",src:t(8656).A+"",width:"997",height:"413"})}),"\n",(0,r.jsx)(n.h3,{id:"understanding-the-paradox",children:"Understanding the paradox"}),"\n",(0,r.jsxs)(n.p,{children:["As mindblowing as this is, we can show that the value of ",(0,r.jsx)(n.code,{children:"count"})," may be incorrect by reminding ourselves how operations are implemented in ",(0,r.jsx)(n.strong,{children:"machine language"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-idk",metastring:'title="count++"',children:"register1 = count\nregister1 = register1 + 1\ncount = register1\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-idk",metastring:'title="count--"',children:"register2 = count\nregister2 = register2 - 1\ncount = register2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The concurrent execution of ",(0,r.jsx)(n.code,{children:"count++"})," and ",(0,r.jsx)(n.code,{children:"count--"})," is equivalent to a sequential execution in which the lower-level statements presented previously are ",(0,r.jsx)(n.strong,{children:"interleaved"})," in some arbitrary order (but the order within each high-level statement is preserved). One such interleaving is the following:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"interleaving",src:t(9267).A+"",width:"770",height:"205"})}),"\n",(0,r.jsx)(n.p,{children:"We would arrive at this incorrect state because we allowed both processes to manipulate the variable count concurrently!"}),"\n",(0,r.jsx)(n.admonition,{title:"RACE CONDITION",type:"tip",children:(0,r.jsxs)(n.p,{children:["A situation like this, where several processes access and manipulate the same data concurrently and the outcome of the execution depends on the particular order in which the access takes place, is called a ",(0,r.jsx)(n.strong,{children:"race condition"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8656:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/count_issue-980f0ea1cdf49d03f5ef8978f13c1168.png"},9267:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/interleaving-ad02832e38a9697817d196f573f0bcac.png"},5905:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/meme-5c564dc93f271f37be269b3ac2e40ed8.jpg"},3010:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/ring_buffer-236c1bed74884b191b184f840a85e288.png"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);