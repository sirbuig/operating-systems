"use strict";(self.webpackChunkoperating_systems=self.webpackChunkoperating_systems||[]).push([[7014],{1527:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>t,metadata:()=>l,toc:()=>o});var a=n(4848),r=n(8453);const t={sidebar_position:1,title:"Examen 2019 SO VAR1",description:"Solution to the exam"},s="Examen 2019 VAR 1 Seria 23 - 25",l={id:"modele-examen/examen_2019_var1",title:"Examen 2019 SO VAR1",description:"Solution to the exam",source:"@site/docs/modele-examen/examen_2019_var1.md",sourceDirName:"modele-examen",slug:"/modele-examen/examen_2019_var1",permalink:"/operating-systems/modele-examen/examen_2019_var1",draft:!1,unlisted:!1,editUrl:"https://github.com/sirbuig/operating-systems/tree/main/docs/modele-examen/examen_2019_var1.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Examen 2019 SO VAR1",description:"Solution to the exam"},sidebar:"tutorialSidebar",previous:{title:"Examene",permalink:"/operating-systems/category/examene"},next:{title:"Examen 2024 SO 29.01.2024",permalink:"/operating-systems/modele-examen/examen_2024"}},c={},o=[{value:"Exercitiul 1",id:"exercitiul-1",level:2},{value:"Exercitiul 2",id:"exercitiul-2",level:2},{value:"Exercitiul 3",id:"exercitiul-3",level:2},{value:"Exercitiul 4",id:"exercitiul-4",level:2}];function d(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"examen-2019-var-1-seria-23---25",children:"Examen 2019 VAR 1 Seria 23 - 25"})}),"\n",(0,a.jsx)(i.h2,{id:"exercitiul-1",children:"Exercitiul 1"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Ce este un proces zombie?"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Raspuns: Un proces din the last of us"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Scrieti o secventa scurta de cod si aratati cand un proces devine zombie"})}),"\n",(0,a.jsxs)(i.p,{children:["Verifica aici:\r\n",(0,a.jsx)(i.a,{href:"https://sirbuig.github.io/operating-systems/week-4/zombie_orphans",children:"https://sirbuig.github.io/operating-systems/week-4/zombie_orphans"})]}),"\n",(0,a.jsx)(i.h2,{id:"exercitiul-2",children:"Exercitiul 2"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-c",children:"for(i = 0; i < n; i++){\r\n    fork();\r\n    pthread_create();\r\n    fork();\r\n}\n"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Cate procese si fire de executie sunt create?"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Raspuns:","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Avem un loop care merge de n ori => n",(0,a.jsx)(i.em,{children:"2 fork() = 2^(n"}),"2) procese create."]}),"\n",(0,a.jsx)(i.li,{children:"Pentru i = 0 avem 2 threaduri"}),"\n",(0,a.jsx)(i.li,{children:"Pentru i = 1 avem 2 threaduri + 8 threaduri"}),"\n",(0,a.jsx)(i.li,{children:"Pentru i = 2 avem 2 + 8 + 32 threaduri"}),"\n",(0,a.jsx)(i.li,{children:"Algoritmul general (just for fun): 2(4^n - 1)/3 threaduri"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"exercitiul-3",children:"Exercitiul 3"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-c",children:"do{\r\n    wait(chopstick[i]);\r\n    wait(chopstick[(i+1)%n]);\r\n    // ...\r\n    signal(chopstick[i]);\r\n    signal(chopstick[(i+1)%n]);\r\n\r\n}while(true);\n"})}),"\n",(0,a.jsx)(i.p,{children:"Aceasta problema permite aparitia fenomenului de deadlock."}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Modificati solutia ridicand asimetric betisoarele: filosofii impari ridica intai betisorul din stanga, cei pari pe cel din dreapta. Aratati ca nu mai apare fenomenul."})}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-c",children:"do{\r\n    if (i%2 == 1) {\r\n        wait(chopstick[i]);\r\n        wait(chopstick[(i+1)%n]);\r\n\r\n    } else {\r\n        wait(chopstick[(i+1)%n]);\r\n        wait(chopstick[i]);\r\n    }\r\n\r\n    // ...\r\n\r\n    signal(chopstick[i]);\r\n    signal(chopstick[(i+1)%n]);\r\n}while(true);\n"})}),"\n",(0,a.jsx)(i.p,{children:"Problema cu prima varianta era ca daca toti filozofii ridica betisorul din stanga in acelasi timp, o sa intre in deadlock. Asadar, daca cei impari ridica stanga si cei pari dreapta, atunci o sa ramana macar un bestisor liber pentru cineva ca sa manance, candva."}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Aratati daca noua solutie satisface cele trei proprietati: exclusivitate mutuala, progres si timp finit de asteptare."})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Raspuns:","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Exclusivitate mutuala este indeplinita intrucat codul implementeaza un semafor (avem wait si signal in format corect)"}),"\n",(0,a.jsx)(i.li,{children:"Pentru ca prevenim deadlock, atunci progresul se satisface prin ce am spus mai devreme la primul subpunct."}),"\n",(0,a.jsx)(i.li,{children:"La timp finit de asteptare nu este specificat un mecanism care sa limiteze timpul de stat la coada pentru a manca."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"exercitiul-4",children:"Exercitiul 4"}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Fie o matrice A apartine N 10x10 tinuta contiguu in memorie pe linii si un sistem in care avem 3 frame-uri disponibile. In acest sistem intr-o pagina incap 10 intregi, iar programele P1 si P2 de mai jos incap in totalitate intr-o pagina."})}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-c",children:"// P1\r\nfor(i = 0; i < 10; i++) {\r\n    for(j = 0; j < 10; j++) {\r\n        A[i][j] = 0;\r\n    }\r\n}\r\n\r\n// P2\r\nfor(j = 0; j < 5; j++) {\r\n    for(i = 0; i < 5; i++) {\r\n        A[i][j] = 0;\r\n    }\r\n}\n"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Observatii: Primul program completeaza pe linii, iar al doilea pe coloane"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Cum arata programul si datele repartizate pe pagini?"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Raspuns:","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Pentru primul program, fiecare linie poate fi pusa intr-o singura pagina (10 intregi per pagina), deci o sa avem nevoie de 10 pagini + o pagina pentru program = ",(0,a.jsx)(i.code,{children:"11 pagini"})]}),"\n",(0,a.jsxs)(i.li,{children:["Pentru al doilea program, 2 linii pot fi puse pe o pagina, deci o sa avem nevoie de 3 pagini (2 pagini pentru primele 4 linii si o pagina pentru ultima linie, cu o fragmentare interna de 5 intregi) + o pagina pentru programul in sine = ",(0,a.jsx)(i.code,{children:"4 pagini"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Folosind algoritmul LRU, care este programul eficient? De ce?"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Materie: Daca vorbim de LRU suntem acum pe memoria fizica (frame), paginile erau pentru zona virtuala."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Raspuns:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsx)(i.p,{children:"Programul eficient este P1, deoarece nu o sa aiba atatea page faulturi ca P2."}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:["Explicatie P1: Pe primul frame punem programul, dupa executam A[0][0] = 0. Avem page fault, cautam prima pagina cu prima linie si o punem in frame din disk. Dupa pentru urmatoarele 9 elemente nu o sa avem probleme. Continuand tot asa o sa avem in ",(0,a.jsx)(i.code,{children:"total 10 page faulturi (pentru fiecare linie)"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:["Explicatie P2: Pe primul frame pune programul, dupa executam A[0][0] = 0, page fault, dupa A[1][0] = 0, e ok pentru ca suntem in aceeasi pagina, dupa A[2][0] = 0 si dam page fault. Problema este ca mergem pe coloane, iar noi avem matricile pus in memorie pe linii (imaginati-va un vector super lung in dreapta). Iar mergand pe coloane, o sa fie 'haotic'. Deci o sa avem in total ",(0,a.jsx)(i.code,{children:"15 page faulturi"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.code,{children:"Cum arata diagramele Gannt pentru P1 si P2?"})}),"\n",(0,a.jsx)(i.p,{children:"Desenati explicit pe o banda temporala ce pagini se acceseaza."}),"\n",(0,a.jsx)(i.p,{children:"e.g. pentru P1 de la timpul 0 la timpul 9 se acceseaza pagina 1..."})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>l});var a=n(6540);const r={},t=a.createContext(r);function s(e){const i=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(t.Provider,{value:i},e.children)}}}]);